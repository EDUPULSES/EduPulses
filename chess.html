<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EduPulse Chess | Grandmaster Edition</title>
    
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #0f172a;
            --panel: #1e293b;
            --accent: #38bdf8;
            --text: #f1f5f9;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
        }

        /* Header & Status */
        .header { text-align: center; margin-bottom: 20px; }
        h1 { margin: 0; font-size: 2rem; color: var(--accent); }
        #status { margin-top: 10px; font-weight: bold; color: #cbd5e1; }

        /* The Board */
        #myBoard {
            width: 90vw;
            max-width: 500px; /* Limits size on PC */
            margin: 0 auto;
            border: 5px solid var(--panel);
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        /* Controls */
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: 0.2s;
        }

        .btn-reset { background: var(--accent); color: #000; }
        .btn-reset:hover { background: #7dd3fc; }
        
        .btn-home { background: var(--panel); color: white; border: 1px solid var(--accent); }
        .btn-home:hover { background: var(--accent); color: black; }

        /* Highlight Move */
        .highlight-white { box-shadow: inset 0 0 3px 3px yellow; }
        .highlight-black { box-shadow: inset 0 0 3px 3px blue; }

        /* Mobile Adjustments */
        @media (max-width: 600px) {
            h1 { font-size: 1.5rem; }
            #myBoard { width: 95vw; }
        }
    </style>
</head>
<body>

    <div class="header">
        <h1>ðŸ§  Neural Chess AI</h1>
        <div id="status">White to move</div>
    </div>

    <div id="myBoard"></div>

    <div class="controls">
        <a href="index.html"><button class="btn-home">Exit</button></a>
        <button class="btn-reset" onclick="resetGame()">New Game</button>
    </div>

    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <script>
        var board = null;
        var game = new Chess();
        var $status = $('#status');
        
        // --- CONFIGURATION ---
        // Depth 3 is smart but fast. Depth 4 is Grandmaster level but slow in browser.
        const AI_DEPTH = 3; 

        // Piece Values (AI Logic)
        const weights = { p: 10, n: 30, b: 30, r: 50, q: 90, k: 900 };
        const pst = {
            p: [ [100, 100, 100, 100, 105, 100, 100, 100], [78, 83, 86, 73, 102, 82, 85, 90], [7, 29, 21, 44, 40, 31, 44, 7], [-17, 16, -2, 15, 14, 0, 15, -13], [-26, 3, 10, 9, 6, 1, 0, -23], [-22, 9, 5, -11, -10, -2, 3, -19], [-31, 8, -7, -37, -36, -14, 3, -31], [0, 0, 0, 0, 0, 0, 0, 0] ],
            n: [ [-66, -53, -75, -75, -10, -55, -58, -70], [-3, -6, 100, -36, 4, 62, -4, -14], [10, 67, 1, 74, 73, 27, 62, -2], [24, 24, 45, 37, 33, 41, 25, 17], [-1, 5, 31, 21, 22, 35, 2, 0], [-18, 10, 13, 22, 18, 15, 11, -14], [-23, -15, 2, 0, 2, 0, -23, -20], [-74, -23, -26, -24, -19, -35, -22, -69] ],
            b: [ [-59, -78, -82, -76, -23, -107, -37, -50], [-11, 20, 35, -42, -39, 31, 2, -22], [-9, 39, -32, 41, 52, -10, 28, -14], [25, 17, 20, 34, 26, 25, 15, 10], [13, 10, 17, 23, 17, 16, 0, 7], [14, 25, 24, 15, 8, 25, 20, 15], [19, 20, 11, 6, 7, 6, 20, 16], [-7, 2, -15, -12, -14, -15, -10, -10] ],
            r: [ [35, 29, 33, 4, 37, 33, 56, 50], [55, 29, 56, 67, 55, 62, 34, 60], [19, 35, 28, 33, 45, 27, 25, 15], [0, 5, 16, 13, 18, -4, -9, -6], [-28, -35, -16, -21, -13, -29, -46, -30], [-42, -28, -42, -25, -25, -35, -26, -46], [-53, -38, -31, -26, -29, -43, -44, -53], [-30, -24, -18, 5, -2, -18, -31, -32] ],
            q: [ [6, 1, -8, -104, 69, 24, 88, 26], [14, 32, 60, -10, 20, 76, 57, 24], [-2, 43, 32, 60, 72, 63, 43, 2], [1, -16, 22, 17, 25, 20, -13, -6], [-14, -15, -2, -5, -1, -10, -20, -22], [-30, -6, -13, -11, -16, -11, -16, -27], [-36, -18, 0, -19, -15, -15, -21, -38], [-39, -30, -31, -13, -31, -36, -34, -42] ],
            k: [ [4, 54, 47, -99, -99, 60, 83, -62], [-32, 10, 55, 56, 56, 55, 10, 3], [-62, 12, -57, 44, -67, 28, 37, -31], [-55, 29, 11, -27, -19, -21, 12, -35], [-55, 17, -9, -49, -62, 24, 5, -22], [-47, 60, 37, -41, -29, 44, -10, -17], [-3, 7, -25, 0, -38, -65, -16, -3], [14, 18, -1, -6, -2, 5, 29, -8] ]
        };

        // --- GAME LOGIC ---

        function onDragStart (source, piece) {
            // Prevent dragging if game is over OR if it's the AI's turn
            if (game.game_over() || game.turn() === 'b' || piece.search(/^b/) !== -1) {
                return false;
            }
        }

        function onDrop (source, target) {
            // Try to make the move (default promotion to Queen for simplicity)
            var move = game.move({
                from: source,
                to: target,
                promotion: 'q'
            });

            // Illegal move
            if (move === null) return 'snapback';

            updateStatus();
            
            // Trigger AI after a short delay so UI updates first
            window.setTimeout(makeBestMove, 250);
        }

        function makeBestMove() {
            if (game.game_over()) return;

            $status.text("AI is Thinking...");
            
            // Use setTimeout to allow the browser to render the "Thinking" text
            window.setTimeout(() => {
                var bestMove = minimaxRoot(AI_DEPTH, game, true);
                game.move(bestMove);
                board.position(game.fen());
                updateStatus();
            }, 100);
        }

        // --- AI ENGINE (Minimax + Alpha Beta) ---

        function minimaxRoot(depth, game, isMaximisingPlayer) {
            var newGameMoves = game.moves();
            // Bug Fix: If no moves available (Checkmate/Stalemate), exit immediately
            if (newGameMoves.length === 0) return null; 

            var bestMove = -9999;
            var bestMoveFound;

            for(var i = 0; i < newGameMoves.length; i++) {
                var newGameMove = newGameMoves[i];
                game.move(newGameMove);
                var value = minimax(depth - 1, game, -10000, 10000, !isMaximisingPlayer);
                game.undo();
                if(value >= bestMove) {
                    bestMove = value;
                    bestMoveFound = newGameMove;
                }
            }
            return bestMoveFound;
        }

        function minimax(depth, game, alpha, beta, isMaximisingPlayer) {
            if (depth === 0) {
                return -evaluateBoard(game.board());
            }

            var newGameMoves = game.moves();

            // Safety Fix: If checkmate happens deep in the search tree
            if (newGameMoves.length === 0) {
                if (game.in_checkmate()) return isMaximisingPlayer ? -10000 : 10000;
                return 0; // Stalemate
            }

            if (isMaximisingPlayer) {
                var bestMove = -9999;
                for (var i = 0; i < newGameMoves.length; i++) {
                    game.move(newGameMoves[i]);
                    bestMove = Math.max(bestMove, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
                    game.undo();
                    alpha = Math.max(alpha, bestMove);
                    if (beta <= alpha) {
                        return bestMove;
                    }
                }
                return bestMove;
            } else {
                var bestMove = 9999;
                for (var i = 0; i < newGameMoves.length; i++) {
                    game.move(newGameMoves[i]);
                    bestMove = Math.min(bestMove, minimax(depth - 1, game, alpha, beta, !isMaximisingPlayer));
                    game.undo();
                    beta = Math.min(beta, bestMove);
                    if (beta <= alpha) {
                        return bestMove;
                    }
                }
                return bestMove;
            }
        }

        function evaluateBoard(board) {
            var totalEvaluation = 0;
            for (var i = 0; i < 8; i++) {
                for (var j = 0; j < 8; j++) {
                    totalEvaluation = totalEvaluation + getPieceValue(board[i][j], i, j);
                }
            }
            return totalEvaluation;
        }

        function getPieceValue(piece, x, y) {
            if (piece === null) return 0;
            
            var getAbsoluteValue = function (piece, isWhite, x ,y) {
                if (piece.type === 'p') return 10 + (isWhite ? pst.p[y][x] : pst.p[7 - y][x]);
                if (piece.type === 'r') return 50 + (isWhite ? pst.r[y][x] : pst.r[7 - y][x]);
                if (piece.type === 'n') return 30 + (isWhite ? pst.n[y][x] : pst.n[7 - y][x]);
                if (piece.type === 'b') return 30 + (isWhite ? pst.b[y][x] : pst.b[7 - y][x]);
                if (piece.type === 'q') return 90 + (isWhite ? pst.q[y][x] : pst.q[7 - y][x]);
                if (piece.type === 'k') return 900 + (isWhite ? pst.k[y][x] : pst.k[7 - y][x]);
                return 0;
            };

            var absoluteValue = getAbsoluteValue(piece, piece.color === 'w', x ,y);
            return piece.color === 'w' ? absoluteValue : -absoluteValue;
        }

        // --- UI UPDATES ---

        function updateStatus() {
            var statusText = '';
            var moveColor = 'White';
            if (game.turn() === 'b') moveColor = 'Black';

            if (game.in_checkmate()) {
                statusText = 'Game Over: ' + moveColor + ' is in checkmate.';
            } else if (game.in_draw()) {
                statusText = 'Game Over: Drawn position';
            } else {
                statusText = moveColor + ' to move';
                if (game.in_check()) statusText += ', ' + moveColor + ' is in check';
            }
            $status.text(statusText);
        }

        function resetGame() {
            game.reset();
            board.start();
            updateStatus();
        }

        // Initialize Board
        var config = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
        }
        board = Chessboard('myBoard', config);
        updateStatus();

        // Handle Window Resize
        window.addEventListener('resize', () => {
            board.resize();
        });

    </script>
</body>
</html>